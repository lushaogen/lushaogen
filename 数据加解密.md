# 数据加解密

## **MD5**

1)   简介

MD5加密算法（Message Digest Algorithm MD5）

MD5就是信息摘要的一种实现，它可以从任意长度的明文字符串转化为128位的Hash（哈希）值。

2)   MD5 算法底层原理： 

MD5 算法的过程分为四步：处理原文，设置初始值，循环加工，拼接结果。

处理原文

首先，我们计算出原文长度(bit)对 512 求余的结果，如果不等于448，就需要填充原文使得原文对 512 求余的结果等于 448。填充的方法是第一位填充 1，其余位填充 0。填充完后，信息的长度就是 512*N+448。

之后，用剩余的位置（512-448=64 位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是 512*(N+1)。

设置初始值

MD5 的哈希结果长度为 128 位，按每 32 位分成一组共 4 组。这 4 组结果是由 4 个初始值 A、B、C、D 经过不断演变得到。MD5 的官方实现中，A、B、C、D 的初始值如下（16 进制）：

A=0x01234567

B=0x89ABCDEF

C=0xFEDCBA98

D=0x76543210

设置初始值

这一步是最复杂的一步，我们看看下面这张图，此图代表了单次 A,B,C,D 值演变的流程。

![](https://www.tomorrow.wiki/wp-content/uploads/image/20180530/1527611606861807.png)

图中，A，B，C，D 就是哈希值的四个分组。每一次循环都会让旧的 ABCD 产生新的 ABCD。一共进行多少次循环呢？由处理后的原文长度决定。

假设处理后的原文长度是 M

主循环次数 = M / 512

每个主循环中包含 512 / 32 \* 4 = 64 次 子循环。

上面这张图所表达的就是单次子循环的流程。



下面对图中其他元素一一解释：

1.*绿色 F*

图中的绿色 F，代表非线性函数。官方 MD5 所用到的函数有四种：

F(X, Y, Z) =(X&Y) | ((~X) & Z)

G(X, Y, Z) =(X&Z) | (Y & (~Z))

H(X, Y, Z) =XYZ

I(X, Y, Z)=Y^(X|(~Z))

在主循环下面 64 次子循环中，F、G、H、I 交替使用，第一个 16 次使用 F，第二个 16 次使用 G，第三个 16 次使用 H，第四个 16 次使用 I。

2.*红色“田”字*

很简单，红色的田字代表相加的意思。

*3.Mi*

Mi 是第一步处理后的原文。在第一步中，处理后原文的长度是 512 的整数倍。把原文的每 512 位再分成 16 等份，命名为 M0~M15，每一等份长度 32。在 64 次子循环中，每 16 次循环，都会交替用到 M1~M16 之一。

*4.Ki*

一个常量，在 64 次子循环中，每一次用到的常量都是不同的。

5.*黄色的<<

左移 S 位，S 的值也是常量。

“流水线”的最后，让计算的结果和 B 相加，取代原先的 B。新 ABCD 的产生可以归纳为：

新 A = 原 d

**新 B = b+((a+F(b,c,d)+Mj+Ki)<<

新 C = 原 b

新 D = 原 c

l 拼接结果

这一步就很简单了，把循环加工最终产生的 A，B，C，D 四个值拼接在一起，转换成字符串即可。

3)   MD5的破解方法：

暴力枚举法、字典法、彩虹表法三种破解MD5加密算法的方法。

介绍：MD5的破解并不是还原出明文的字符串，因为128位的MD5摘要是有穷的，而原文数量是无穷的，每个摘要都是若干原文通过hash得到。对于MD5可以生成摘要M，我们并不需要把加密后的X还原成A，只需要找到原文B，生成同样的MD5.

暴力破解法：不用过多的解释了，就是枚举出所有的原文，并计算他们的哈希值，看看哪个哈希值和给定的信息摘要一致，虽然实现简单，但是时间很漫长。8位密码长度，只包含大小写字母和数字，每一位有62种可能，那么8位密码的排列组合就是62的8次方。200万亿次。

字典法：用一个巨大的字典存储对应的哈希值，然后每次进行快速定位，但是需要大量的数据存储，8位密码的组合数据存储就需要4.65PB；

**彩虹表：**

**H（X）**：生成信息摘要的哈希函数，比如MD5，比如SHA256。**

**R（X）**：从信息摘要转换成另一个字符串的衰减函数（Reduce）。其中R（X）的定义域是H（X）的值域，R（X）的值域是H（X）的定义域。但要注意的是，R（X）并非H（X）的反函数。**

通过交替运算H和R若干次，可以形成一个原文和哈希值的链条。假设原文是aaaaaa，哈希值长度32bit，那么哈希链表就是下面的样子：

![](https://i.loli.net/2020/04/06/NmLJfYCSe7xowWG.jpg)

这个链条有多长呢？假设H（X）和R（X）的交替重复K次，那么链条长度就是2K+1。同时，我们只需把链表的首段和末端存入哈希表中：

![](https://i.loli.net/2020/04/06/yarCpsGuWLTMoBz.jpg)

彩虹表的实现就是利用哈希链进行多次碰撞来演算出原文的摘要。从而达到破解的目的。



## AES算法

AES算法是典型的【对称加密算法】，它不同于MD5、SHA这样的哈希摘要算法，他是真正意义上的加密算法。

因为摘要算法是不可逆的，也就是说他是通过摘要无法还原为明文的，主要作用是对信息一致性和完整性进行校验。

对称加密算法是可逆的，他的主要作用是保护私密信息不被泄露。

AES的全称是Advanced Encryption Standard，意思是高级加密标准。

1)   密钥：

密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用同一个密钥。

AES支持三种长度的密钥：

128位，192位，256位

平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。

AES128加密性能最高，AES256加密安全性最高。主要因为加密处理的轮数不同。

2)   填充

我们先要了解AES的分组加密特性。

![](https://i.loli.net/2020/04/06/Wiy1vMm42hjHZXz.jpg)

AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。

这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。

但是这里涉及到一个问题：

假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行填充（Padding）。

